# 前言

模块化、组件化这些概念在前端日益完善的今天，已经不再是什么新词。层出不穷的轮子，让我们眼花缭乱，只要了解其中原理，才能直戳要害，才能让我们在百花齐放的前端面前保持正定从容。今天就让我们来聊一聊前端独立性。

首先我们先从js讲起，js一开始是被定义为脚本语言，起初只是处理一些网页上的简单的逻辑，但随着前端技术的高速发展，前端承担的工作日渐复杂，原来的工作方式已经无法满足我们项目开发，和许多语言一样，我们开始研究开发模式，模块化，那其追求的核心是什么？答案显而易见，**更好的管理**。

js从一开始的amd/cmd到commonJs,到ECMA想把模块化规范统一，这些模块化的核心是什么，或者说其设计之初的缘由是什么。无非是**独立性**，把代码按功能划分，按需结合。我们无需理会其如何工作，只需知道其api使用方式即可，这大大增加我们的工作效率。


*以node举例，我们打算开发一个音乐盒，我们会如何分模块*

首先我们写js，需要一个工具库，这有利于我们的开发。

> tool.js

    //我们创建一个对象(工具箱)
    
    var tool = {};
    
    //往这个工具箱中添加各种工具
    
    tool.toArray = function(){
        //工作代码
    }
    
    //往外抛出这个工具箱
    module.exports = tool;

开发音箱

> audioDevice

    function AudioDevice(){
        //开发音箱
    }


开发音乐盒

> musicBox.js

    //这里我们要开发
    
    //我们把音箱引进来
    var AudioDevice = require('./audioDevice');
    
    function MusicBox(){
        //把音箱功能接入音乐盒中
        this.audioDevice = new AudioDevice();
        //开发音乐盒
    }


从上面的例子中，我们就可以看到模块化的好处，我们把音乐盒的开发拆分成很多块，比如零件，有音箱，按钮等等，还有开发的时候所用的工具库，我们把这些独立出来后，我对我们的开发效率有着大大的提高。还有这也有助于我们的维护，如果出现问题，我们只要到相应的地方维护即可，如果我们想开发新的功能，只需要另开辟即可，不会影响到其他的功能。

前端人的野心是永无止境的，在js模块化诞生后，人们又把矛头指向了css。既然js可以这么做，为何css不可，很快，就诞生了less\sass\scss\rework\postcss。

*我们再用scss举一个例子。*

首先我们有个reset文件

> reset.scss

    * {
        padding:0;
        margin:0;
    }
    

然后有个工具文件

> mixin.scss

    @mixin float($float: left) {
        float: $float;
    }

然后我们页面文件

> style.scss
    
    //我们先引入我们要使用的scss
    @import "xxx";
    
    //业务css


这样我们的css也变得和js一样有层次，业务和功能的**独立性**增强，我们的工作也变得更好的管理。


然而仅仅有了js和css的模块化是不够的，前端由三部分组成，html、css、js。最核心的html我们还没有处理怎么能甘心呢，于是我们也开始对前端进行模块化，一开始最有名的莫过于boostrap了。通过复制结构，和css可以拼凑出我们想要的东西，但是！(前端永不缺造轮之心),这还有很大的局限性，它无法完成高定制的页面，还有它的封装不够彻底。
于是怀着一颗永不满足的心，angular等框架面世，随后react大法、vue神棍相继冒出。前端迎来组件化的时代。

何为组件化。其实就是按功能模块进行划分，把其封装成一个模块，与js模块化和css模块化类似(仅为类似，因为组件化需要把这些结合于其中)，高度封装，高度**独立**,互不影响。

*我们来看看组件化的工作方式*

书写组件

    <template>
        <!-- 组件的书写-->
    </template>
    <script>
        //组件的js逻辑书写
    </script>

主页面主要由相应的组件说明拼凑而成

    <html>
    <body>
        <component src="/head"/>
        <component src = "/content"/>
        <component src = "/footer"/>
    </body>
    </html>

每个组件都是**独立的**(包含js独立、css独立)，每个之间互不影响，再通过vm做交互。这有效的提高了我们的工作效率。

*常见误解:组件化 == 复用性*

复用性是我们组件化的一个特性，也就是其中的一个作用，我们一般把组件分为两种：一种是业务组件，一种是功能组件。如Mint、element这些都是属于功能组件，一般做管理系统时我们会常使用，**其最重要的特性就是复用性了**。而业务组件，就和我们上面那个例子一样，它是组成页面的基本模块，其组件中可能还会嵌套很多组件，**其最重要的特性是维护性**，下面我们再举个例子来说明。


现在我们完成了一个页面
![](/assets/1.png)

有一天我们这个页面要改版了，绿色框内要改版
![](/assets/4.png)

如果按传统的方式，我们需要找到当时的html，css，js。然后密密麻麻的代码，如果这个页面是你写的还好，自己起码还有点印象，如果是别人写的，你来改，那真可以体会什么叫代码的鸿沟。

如果使用组件的方式来写的化
![](/assets/2.png)

我们把这个页面分成三个大模块
代码如下：
    
    <html>
    <body>
        <component src="/module1"/>
        <component src="/module2"/>
        <component src="/module3"/>
    </body>
    </html>

和上面一样，如果我们遇到了改版
![](/assets/3.png)

我们只要找到module3的代码修改即可，这对前两个的影响会降得很低。而且这样我们的改版速度也会大大增加。

**而且业务组件还有一个很大的好处，那就是如果遇到相识的组件时，我们只要找到相识的组件，复制修改即可，这也大大减少了我们的工作量。**

## ueb

你是否已经体会到前端演变带来的便利了呢？是否已经蠢蠢欲动了呢，可以理想很美好，现实很残酷，我们很多项目是老项目，它有它自己固有的体系架构，我们不是那么容易的引入新的技术，难道我们要屈服吗，不！(前端永不缺造轮之心)。狼叔说过：“没有最好的技术，只有最好的程序员”。只要我们理解了模块化和组件化的理念，我们一样可以造出自己的轮子。

> 总结理念

模块化和组件化的核心是什么？
 
**高内聚，低耦合**

模块化和组件化的目的是什么？

**让项目更具有复用性和维护性**

> 分析现状

* 现html和css都还是使用原始的方式。

* js分为wap端和pc端，无论wap端还是pc端都是使用了AMD规范，但他们两个的构建有所不同，pc端是通过引入ganji.js就可以使用。而wap端是通过grunt构建工具构建后引入g.js才可以使用。

* UE组平常主要工作UE设计，js涉及较少。

> 结论

* 为pc端和wap端提供开发环境。

* 只包含html和css的组件化

> 初步构想

应用包含开发环境和生产环境，开发环境提供组件化和js环境。生产环境打包出能在线上运行的代码。

> 工作方式设想

组件我们分为业务组件和功能组件，功能组件我们使用DMUI来统一管理，业务组件在自己创建的项目当中，功能组件使用`is`属性来引用，业务组件使用`src`来引用。



